# from libcst._nodes.module import Module
# from libcst._nodes.statement import ClassDef
from libcst._nodes.module import Module
from typing import Sequence
import libcst as cst

# from libcst import (
#     # SimpleStatementLine,
#     # BaseSuite,
#     Expr,
#     # SimpleString,
#     # ConcatenatedString,
# )

from libcst.helpers import parse_template_expression, ensure_type

py_source = '''
'moduledoc'
class Signal:
    ''
    def value(self):
        ''
        pass

class Foo:
    """
    """
    def __init__(self):
        ''
        pass

'''


config = cst.PartialParserConfig(python_version="3.5")
source_tree = cst.parse_module(py_source, config)

print(source_tree.get_docstring())

source_tree.code_for_node(source_tree.children[3])

##  select a class definition - Q&D
classdef = source_tree.children[2]
assert isinstance(classdef, cst.ClassDef), "Not a classdef"


## class docstring 1: ''
#    body=IndentedBlock(
#         body=[
#         SimpleStatementLine(
#             body=[
#                 Expr(
#                     value=SimpleString(
#                         value="''",
#                         lpar=[],
#                         rpar=[],
#                     ),
#                     semicolon=MaybeSentinel.DEFAULT,
#                 ),
#             ],
#             leading_lines=[],
#             trailing_whitespace=TrailingWhitespace(
#                 whitespace=SimpleWhitespace(
#                     value='',
#                 ),
#                 comment=None,
#                 newline=Newline(
#                     value=None,
#                 ),
#             ),
#         ),
#         FunctionDef( ....


## class docstring 2: """ multiline """

# body=IndentedBlock(
#         body=[
#             SimpleStatementLine(
#                 body=[
#                     Expr(
#                         value=SimpleString(
#                             value='"""\n    """',
#                             lpar=[],
#                             rpar=[],
#                         ),
#                         semicolon=MaybeSentinel.DEFAULT,
#                     ),
#                 ],
#                 leading_lines=[],
#                 trailing_whitespace=TrailingWhitespace(
#                     whitespace=SimpleWhitespace(
#                         value='',
#                     ),
#                     comment=None,
#                     newline=Newline(
#                         value=None,
#                     ),
#                 ),
#             ),
#             FunctionDef(

# docstring-1 can be generated by

# >>> print(cst.parse_statement("''", config))
# SimpleStatementLine(
#     body=[
#         Expr(
#             value=SimpleString(
#                 value="''",
#                 lpar=[],
#                 rpar=[],
#             ),
#             semicolon=MaybeSentinel.DEFAULT,
#         ),
#     ],
#     leading_lines=[],
#     trailing_whitespace=TrailingWhitespace(
#         whitespace=SimpleWhitespace(
#             value='',
#         ),
#         comment=None,
#         newline=Newline(
#             value=None,
#         ),
#     ),
# )

print(cst.parse_statement('"""\n"""', config))


# the classdef's body
body = classdef.body

if isinstance(body, Sequence):
    if body:
        expr = body[0]  # lgtm [py/multiple-definition]
    else:
        # fixme: what to do if there is no body
        assert False, "there is no body"


source_tree.code_for_node(body)
source_tree.code_for_node(body.body[0])


expr = body
while isinstance(expr, (cst.BaseSuite, cst.SimpleStatementLine)):
    if len(expr.body) == 0:
        # fixme: what to do if there is no body
        assert 1, "body does not start with block or docstring"
    expr = expr.body[0]

if not isinstance(expr, cst.Expr):
    # fixme: what to do if there is no initial docstr Expression in the body
    assert 1, "there is no Expression in the body"


print(source_tree.code_for_node(expr))


# new_docstr = parse_template_expression("'new docs string'", config=config)
new_docstr = expr.with_changes(value=parse_template_expression("new \ndoc\nstring", config=config))

print(source_tree.code_for_node(new_docstr))
newtree = ensure_type(source_tree.deep_replace(expr, new_docstr), Module)

print(newtree.code)


print("Done")

# source_tree.code_for_node( body )
# body.deep_replace()
# source_tree.code_for_node( body )


# classdef.ch
